<!-- templates/index.html — full file (relocated buttons, big prompt under panes, speed/quality tips) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
  />
  <title>Webcam ⇢ Real-Time LCM (img2img)</title>
  <link rel="icon" href="/static/favicon.ico" />
  <script type="importmap">
    {
      "imports": {
        "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/dist/lil-gui.esm.min.js"
      }
    }
  </script>
  <style>
    :root { --gap: 14px; --panel:#111114; --border:#242428; --text:#e9e9ea; --muted:#b8b8be; }
    html, body { margin:0; padding:0; background:#0b0b0c; color:var(--text); font: 14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .wrap { display:flex; flex-direction:column; min-height:100svh; }
    header { padding:10px var(--gap); font-weight:700; letter-spacing:.3px; font-size:16px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: var(--gap); padding: 0 var(--gap) var(--gap); }
    .pane { background:var(--panel); border:1px solid var(--border); border-radius:14px; overflow:hidden; position:relative; min-height:40svh; }
    .pane h3 { position:absolute; z-index:2; top:8px; left:10px; margin:0; font-size:12px; letter-spacing:.3px; opacity:.8; background:rgba(0,0,0,.35); padding:4px 6px; border-radius:8px; }
    video, img, canvas { width:100%; height:100%; object-fit:cover; display:block; }
    #overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.8); color:#fff; z-index:9999; text-align:center; padding:24px; }
    #overlay.show { display:flex; }

    /* Controls area under the panes */
    .controls { display:grid; grid-template-columns: 1fr; gap: var(--gap); padding: 0 var(--gap) var(--gap); }
    .action-row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .action-row .spacer { flex:1; }
    .btn {
      background:#2a2a2e; color:#fff; border:1px solid #3a3a3f; border-radius:10px; padding:10px 14px; cursor:pointer;
    }
    .btn:disabled { opacity:.55; cursor:not-allowed; }
    .status { font-size:12px; opacity:.9; padding:6px 10px; border-radius:999px; border:1px solid #2a2a2e; background:#151518; }
    .row { display:grid; grid-template-columns: 1fr; gap:8px; }
    label { font-size:12px; color:var(--muted); }
    textarea {
      width:100%; min-height:90px; resize:vertical; padding:10px 12px; border-radius:12px;
      border:1px solid var(--border); background:#141416; color:#fff; font: 14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    }

    .tips { background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px; color:#d7d7db; }
    .tips strong { color:#fff; }
    .tips ul { margin:8px 0 0 18px; padding:0; }
    .tips li { margin:4px 0; }

    footer { padding: 8px var(--gap) var(--gap); opacity:.7; font-size:12px; }

    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
      .pane { min-height:45svh; }
    }
  </style>
</head>
<body>
  <div id="overlay" class="show">
    <div>
      <div style="font-size:18px; margin-bottom:8px;">Secure context required</div>
      <div>Open via <strong>https://localhost:5000</strong> or <strong>https://&lt;your-mac-ip&gt;:5000</strong> and accept the certificate.</div>
    </div>
  </div>

  <div class="wrap">
    <header>Webcam ⇢ Real-Time LCM (img2img)</header>

    <div class="grid">
      <div class="pane">
        <h3>Webcam</h3>
        <video id="cam" autoplay playsinline muted></video>
      </div>
      <div class="pane">
        <h3>Output</h3>
        <img id="out" alt="Model output" />
      </div>
    </div>

    <section class="controls">
      <div class="action-row">
        <button id="btnScan"  class="btn">Scan cameras</button>
        <button id="btnStart" class="btn">Start live</button>
        <button id="btnStop"  class="btn">Stop live</button>
        <button id="btnSnap"  class="btn">Process one frame</button>
        <span class="spacer"></span>
        <span id="httpHint" class="status">http/https</span>
        <span id="status" class="status">idle</span>
      </div>

      <div class="row">
        <label for="promptInput">Prompt</label>
        <textarea id="promptInput" placeholder="Describe the look you want (e.g., ‘cinematic portrait, dramatic lighting, shallow depth of field’)">cinematic portrait, dramatic lighting</textarea>
      </div>

      <div class="tips">
        <strong>Speed vs. Quality</strong>
        <ul>
          <li><strong>Faster:</strong> Steps 2–4, Guidance 0–2, lower capture resolution (e.g., 640×480).</li>
          <li><strong>More stylized:</strong> Higher Strength (0.6–0.9) deviates more from the webcam frame.</li>
          <li><strong>More faithful:</strong> Lower Strength (0.2–0.5) keeps the original structure.</li>
          <li><strong>Sharper but slower:</strong> Steps 6–8 and higher resolution.</li>
        </ul>
      </div>
    </section>

    <footer>Keep Steps low (2–4) for real-time feel. LCM likes low Guidance (0–2). Use HTTPS so browsers show camera devices.</footer>
  </div>

  <canvas id="hidden" style="display:none;"></canvas>

  <script type="module">
    import { GUI } from "lil-gui";

    // Secure-context gate
    const overlay = document.getElementById("overlay");
    const secure = location.protocol === "https:" || ["localhost", "127.0.0.1", "[::1]"].includes(location.hostname);
    if (secure) overlay.classList.remove("show");

    // DOM refs
    const cam = document.getElementById("cam");
    const out = document.getElementById("out");
    const hidden = document.getElementById("hidden");
    const ctx = hidden.getContext("2d");
    const statusEl = document.getElementById("status");
    const promptEl = document.getElementById("promptInput");

    // Action buttons
    const btnScan  = document.getElementById("btnScan");
    const btnStart = document.getElementById("btnStart");
    const btnStop  = document.getElementById("btnStop");
    const btnSnap  = document.getElementById("btnSnap");
    const httpHint = document.getElementById("httpHint");
    httpHint.textContent = location.protocol === "https:" ? "https ✓" : "http (limited camera labels)";

    // State
    let currentStream = null;
    let inFlight = false;
    let avgLatencyMs = 900;
    let liveTimer = null;

    // GUI (compact for camera + params)
    const state = {
      Prompt: promptEl.value,
      Strength: 0.5,
      Guidance: 1.0,
      Steps: 4,
      Live: false,

      Camera: "(click Scan)",
      Facing: "user",
      Resolution: "1280x720",
      Flip_X: false,
      Flip_Y: false
    };

    const gui = new GUI({ title: "Camera & Params" });
    const gCam = gui.addFolder("Camera"); gCam.open();
    const gModel = gui.addFolder("Model"); gModel.open();

    const ctrlCamera = gCam.add(state, "Camera", ["(click Scan)"]).name("Device").onChange(onCameraChanged);
    gCam.add(state, "Facing", ["user", "environment", "none"]).onChange(restartStream);
    gCam.add(state, "Resolution", ["640x480","1280x720","1920x1080"]).onChange(restartStream);
    gCam.add(state, "Flip_X").onChange(()=>{});
    gCam.add(state, "Flip_Y").onChange(()=>{});

    gModel.add(state, "Strength", 0.05, 1, 0.01);
    gModel.add(state, "Guidance", 0, 6, 0.1);
    gModel.add(state, "Steps", 2, 8, 1);
    const ctrlLive = gModel.add(state, "Live").onChange(toggleLive);

    // Keep state.Prompt in sync with big textarea
    promptEl.addEventListener("input", () => { state.Prompt = promptEl.value; });

    // Camera helpers
    function stopStream() {
      if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); currentStream = null; }
    }

    function selectedDeviceId() {
      const map = ctrlCamera?._idMap || null;
      return map ? (map[state.Camera] || null) : null;
    }

    function parseResolution() {
      const [w, h] = state.Resolution.split("x").map(Number);
      return { width: { ideal: w }, height: { ideal: h } };
    }

    async function restartStream() {
      if (!secure) return;
      stopStream();
      try {
        const devId = selectedDeviceId();
        const base = { audio: false, video: { ...parseResolution() } };
        if (devId) base.video.deviceId = { exact: devId };
        else if (state.Facing !== "none") base.video.facingMode = { ideal: state.Facing };
        const stream = await navigator.mediaDevices.getUserMedia(base);
        currentStream = stream; cam.srcObject = stream; await cam.play();
        statusEl.textContent = "camera ready";
      } catch (e) {
        statusEl.textContent = "camera error";
        console.warn("getUserMedia failed", e);
      }
    }

    async function populateCameras() {
      try {
        if (!secure) return;
        try { const tmp = await navigator.mediaDevices.getUserMedia({video:true,audio:false}); tmp.getTracks().forEach(t=>t.stop()); } catch {}
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === "videoinput");
        const labels = cams.map((d,i)=> d.label || `Camera ${i+1}`);
        const ids = cams.map(d => d.deviceId);

        if (!labels.length) {
          ctrlCamera.options(["(none found)"]).setValue("(none found)");
          ctrlCamera._idMap = {};
          return;
        }
        const map = {}; labels.forEach((name, idx) => map[name] = ids[idx]);
        ctrlCamera._idMap = map;
        const names = Object.keys(map);
        ctrlCamera.options(names);
        if (!names.includes(state.Camera)) ctrlCamera.setValue(names[0]);
        await restartStream();
      } catch (e) {
        console.warn("populateCameras failed", e);
      }
    }

    function onCameraChanged() { restartStream(); }

    // Frame capture
    async function grabFrameBlob(quality = 0.85) {
      const w = cam.videoWidth, h = cam.videoHeight;
      if (!w || !h) return null;
      hidden.width = w; hidden.height = h;
      ctx.save();
      ctx.translate(state.Flip_X ? w : 0, state.Flip_Y ? h : 0);
      ctx.scale(state.Flip_X ? -1 : 1, state.Flip_Y ? -1 : 1);
      ctx.drawImage(cam, 0, 0, w, h);
      ctx.restore();
      return new Promise(resolve => hidden.toBlob(resolve, "image/jpeg", quality));
    }

    // Inference
    async function processOne() {
      if (inFlight) return;
      const frameBlob = await grabFrameBlob(0.85);
      if (!frameBlob) { statusEl.textContent = "no frame yet"; return; }

      inFlight = true;
      const t0 = performance.now();
      try {
        statusEl.textContent = "processing…";
        const fd = new FormData();
        fd.append("frame", frameBlob, "frame.jpg");
        fd.append("prompt", state.Prompt || "");
        fd.append("strength", String(state.Strength));
        fd.append("guidance", String(state.Guidance));
        fd.append("steps", String(state.Steps));

        const res = await fetch("/process", { method: "POST", body: fd });
        if (!res.ok) {
          let msg = `HTTP ${res.status}`;
          try { const j = await res.json(); if (j?.error) msg = j.error; } catch {}
          throw new Error(msg);
        }
        const outBlob = await res.blob();
        if (out.dataset.url) URL.revokeObjectURL(out.dataset.url);
        const url = URL.createObjectURL(outBlob);
        out.dataset.url = url;
        out.src = url;
        statusEl.textContent = "done";
      } catch (e) {
        console.warn("[UI] /process error:", e);
        statusEl.textContent = "error";
      } finally {
        const dt = performance.now() - t0;
        avgLatencyMs = 0.8 * avgLatencyMs + 0.2 * dt;
        if (state.Live && liveTimer) {
          clearInterval(liveTimer);
          liveTimer = setInterval(processOne, Math.max(200, Math.round(avgLatencyMs)));
        }
        inFlight = false;
      }
    }

    function toggleLive(on) {
      state.Live = !!on;
      if (on) {
        statusEl.textContent = "live…";
        if (liveTimer) clearInterval(liveTimer);
        liveTimer = setInterval(processOne, Math.max(200, Math.round(avgLatencyMs)));
        ctrlLive.setValue(true);
      } else {
        statusEl.textContent = "idle";
        if (liveTimer) clearInterval(liveTimer);
        liveTimer = null;
        ctrlLive.setValue(false);
      }
    }

    // Actions
    btnScan.onclick  = () => populateCameras();
    btnStart.onclick = () => toggleLive(true);
    btnStop.onclick  = () => toggleLive(false);
    btnSnap.onclick  = () => processOne();

    // No auto-scan; user clicks "Scan cameras"
  </script>
</body>
</html>
