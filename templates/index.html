<!-- templates/index.html — full file (4 source modes: webcam / upload image / video file / draw in SVG) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
  />
  <title>Realtime LCM (img2img)</title>
  <link rel="icon" href="/static/favicon.ico" />
  <script type="importmap">
    {
      "imports": {
        "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/dist/lil-gui.esm.min.js"
      }
    }
  </script>
  <style>
    :root { --gap: 14px; --panel:#111114; --border:#242428; --text:#e9e9ea; --muted:#b8b8be; }
    html, body { margin:0; padding:0; background:#0b0b0c; color:var(--text); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .wrap { display:flex; flex-direction:column; min-height:100svh; }
    header { padding:10px var(--gap); font-weight:700; letter-spacing:.3px; font-size:16px; }

    /* Source mode switcher */
    .modes { display:flex; gap:8px; padding:0 var(--gap) var(--gap); flex-wrap:wrap; }
    .chip { background:#18181b; border:1px solid #2a2a2e; border-radius:999px; padding:8px 12px; cursor:pointer; user-select:none; }
    .chip.active { background:#2a2a2e; border-color:#3a3a3f; }

    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: var(--gap); padding: 0 var(--gap) var(--gap); }
    .pane { background:var(--panel); border:1px solid var(--border); border-radius:14px; overflow:hidden; position:relative; min-height:40svh; }
    .pane h3 { position:absolute; z-index:2; top:8px; left:10px; margin:0; font-size:12px; letter-spacing:.3px; opacity:.8; background:rgba(0,0,0,.35); padding:4px 6px; border-radius:8px; }
    video, img, canvas { width:100%; height:100%; object-fit:cover; display:block; }

    /* layered sources in left pane; only one visible */
    .src { position:absolute; inset:0; display:none; }
    .src.show { display:block; }

    /* Draw SVG surface */
    #drawWrap { position:absolute; inset:0; }
    #drawSvg { width:100%; height:100%; display:block; background:#0d0d10; touch-action:none; }
    .draw-toolbar { position:absolute; right:10px; top:10px; display:flex; gap:8px; z-index:3; }
    .btn-sm { background:#2a2a2e; color:#fff; border:1px solid #3a3a3f; border-radius:8px; padding:6px 8px; cursor:pointer; font-size:12px; }

    /* Controls under panes */
    .controls { display:grid; grid-template-columns: 1fr; gap: var(--gap); padding: 0 var(--gap) var(--gap); }
    .action-row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .action-row .spacer { flex:1; }
    .btn { background:#2a2a2e; color:#fff; border:1px solid #3a3a3f; border-radius:10px; padding:10px 14px; cursor:pointer; }
    .btn:disabled { opacity:.55; cursor:not-allowed; }
    .status { font-size:12px; opacity:.9; padding:6px 10px; border-radius:999px; border:1px solid #2a2a2e; background:#151518; }
    .row { display:grid; grid-template-columns: 1fr; gap:8px; }
    label { font-size:12px; color:var(--muted); }
    textarea {
      width:100%; min-height:90px; resize:vertical; padding:10px 12px; border-radius:12px;
      border:1px solid var(--border); background:#141416; color:#fff; font: 14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    }

    .tips { background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:12px; color:#d7d7db; }
    .tips strong { color:#fff; }
    .tips ul { margin:8px 0 0 18px; padding:0; }
    .tips li { margin:4px 0; }

    footer { padding: 8px var(--gap) var(--gap); opacity:.7; font-size:12px; }

    #overlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.8); color:#fff; z-index:9999; text-align:center; padding:24px; }
    #overlay.show { display:flex; }

    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
      .pane { min-height:45svh; }
    }
  </style>
</head>
<body>
  <div id="overlay" class="show">
    <div>
      <div style="font-size:18px; margin-bottom:8px;">Secure context required</div>
      <div>Open via <strong>https://localhost:5000</strong> or <strong>https://&lt;your-mac-ip&gt;:5000</strong> and accept the certificate.</div>
    </div>
  </div>

  <div class="wrap">
    <header>Realtime LCM (img2img)</header>

    <!-- Mode chips -->
    <div class="modes">
      <div class="chip active" data-mode="webcam">Webcam</div>
      <div class="chip" data-mode="image">Upload image</div>
      <div class="chip" data-mode="video">Video file</div>
      <div class="chip" data-mode="draw">Draw (SVG)</div>
    </div>

    <div class="grid">
      <!-- LEFT: Source -->
      <div class="pane">
        <h3 id="srcTitle">Source</h3>

        <!-- Webcam -->
        <div id="srcWebcam" class="src show">
          <video id="cam" autoplay playsinline muted></video>
          <div style="position:absolute;left:10px;bottom:10px;display:flex;gap:8px;">
            <button id="btnScan" class="btn-sm">Scan cameras</button>
            <button id="btnSwapFacing" class="btn-sm">Swap facing</button>
          </div>
        </div>

        <!-- Upload image -->
        <div id="srcImage" class="src">
          <input id="fileImage" type="file" accept="image/*" style="position:absolute;z-index:3;left:10px;top:10px" />
          <img id="imgUpload" alt="uploaded" />
        </div>

        <!-- Video file -->
        <div id="srcVideo" class="src">
          <input id="fileVideo" type="file" accept="video/*" style="position:absolute;z-index:3;left:10px;top:10px" />
          <video id="vidFile" autoplay muted loop controls playsinline style="background:#000"></video>
        </div>

        <!-- Draw (SVG) -->
        <div id="srcDraw" class="src">
          <div id="drawWrap">
            <div class="draw-toolbar">
              <button id="drawClear" class="btn-sm">Clear</button>
              <button id="drawUndo" class="btn-sm">Undo</button>
              <button id="drawThin" class="btn-sm">Thin</button>
              <button id="drawThick" class="btn-sm">Thick</button>
            </div>
            <svg id="drawSvg" xmlns="http://www.w3.org/2000/svg"></svg>
          </div>
        </div>
      </div>

      <!-- RIGHT: Output -->
      <div class="pane">
        <h3>Output</h3>
        <img id="out" alt="Model output" />
      </div>
    </div>

    <!-- Controls -->
    <section class="controls">
      <div class="action-row">
        <button id="btnStart" class="btn">Start live</button>
        <button id="btnStop"  class="btn">Stop live</button>
        <button id="btnSnap"  class="btn">Process one frame</button>
        <span class="spacer"></span>
        <span id="httpHint" class="status">http/https</span>
        <span id="status" class="status">idle</span>
      </div>

      <div class="row">
        <label for="promptInput">Prompt</label>
        <textarea id="promptInput" placeholder="Describe the look you want">cinematic portrait, dramatic lighting</textarea>
      </div>

      <div class="tips">
        <strong>Speed vs. Quality</strong>
        <ul>
          <li><strong>Faster:</strong> Steps 2–4, Guidance 0–2, lower source resolution (e.g., 640×480).</li>
          <li><strong>More stylized:</strong> Higher Strength (0.6–0.9) deviates more from the source.</li>
          <li><strong>More faithful:</strong> Lower Strength (0.2–0.5) keeps the structure.</li>
          <li><strong>Sharper but slower:</strong> Steps 6–8 and higher resolution.</li>
        </ul>
      </div>
    </section>

    <footer>Use HTTPS so the browser exposes cameras. LCM prefers low Guidance (0–2). Keep Steps low for realtime feel.</footer>
  </div>

  <canvas id="hidden" style="display:none;"></canvas>

  <script type="module">
    import { GUI } from "lil-gui";

    // Secure-context gate
    const overlay = document.getElementById("overlay");
    const secure = location.protocol === "https:" || ["localhost","127.0.0.1","[::1]"].includes(location.hostname);
    if (secure) overlay.classList.remove("show");

    // DOM refs
    const chips = Array.from(document.querySelectorAll(".chip"));
    const srcTitle = document.getElementById("srcTitle");
    const sections = {
      webcam: document.getElementById("srcWebcam"),
      image : document.getElementById("srcImage"),
      video : document.getElementById("srcVideo"),
      draw  : document.getElementById("srcDraw"),
    };

    const cam = document.getElementById("cam");
    const btnScan = document.getElementById("btnScan");
    const btnSwapFacing = document.getElementById("btnSwapFacing");

    const fileImage = document.getElementById("fileImage");
    const imgUpload = document.getElementById("imgUpload");

    const fileVideo = document.getElementById("fileVideo");
    const vidFile = document.getElementById("vidFile");

    const drawSvg = document.getElementById("drawSvg");
    const drawClear = document.getElementById("drawClear");
    const drawUndo = document.getElementById("drawUndo");
    const drawThin = document.getElementById("drawThin");
    const drawThick = document.getElementById("drawThick");

    const out = document.getElementById("out");
    const hidden = document.getElementById("hidden");
    const ctx = hidden.getContext("2d");

    const statusEl = document.getElementById("status");
    const httpHint = document.getElementById("httpHint");
    const promptEl = document.getElementById("promptInput");

    // state
    const MODE = { WEBCAM:"webcam", IMAGE:"image", VIDEO:"video", DRAW:"draw" };
    let mode = MODE.WEBCAM;

    let currentStream = null;
    let inFlight = false;
    let avgLatencyMs = 900;
    let liveTimer = null;
    let facing = "user"; // for webcam

    httpHint.textContent = location.protocol === "https:" ? "https ✓" : "http (limited cameras)";

    // GUI for numeric params
    const state = {
      Prompt: promptEl.value,
      Strength: 0.5,
      Guidance: 1.0,
      Steps: 4,
      Live: false,

      Camera: "(click Scan)",
      Resolution: "1280x720",
      Flip_X: false,
      Flip_Y: false
    };
    promptEl.addEventListener("input", () => { state.Prompt = promptEl.value; });

    const gui = new GUI({ title: "Params" });
    const gSrc = gui.addFolder("Source");
    const gModel = gui.addFolder("Model"); gModel.open();

    // Webcam device dropdown appears after Scan
    const ctrlCamera = gSrc.add(state, "Camera", ["(click Scan)"]).name("Device").onChange(() => restartWebcam());
    gSrc.add(state, "Resolution", ["640x480","1280x720","1920x1080"]).onChange(()=> {
      if (mode===MODE.WEBCAM) restartWebcam();
    });
    gSrc.add(state, "Flip_X").onChange(()=>{});
    gSrc.add(state, "Flip_Y").onChange(()=>{});

    gModel.add(state, "Strength", 0.05, 1, 0.01);
    gModel.add(state, "Guidance", 0, 6, 0.1);
    gModel.add(state, "Steps", 2, 8, 1);

    // Mode switching
    function setMode(m){
      mode = m;
      Object.values(sections).forEach(el => el.classList.remove("show"));
      if (m===MODE.WEBCAM) { sections.webcam.classList.add("show"); srcTitle.textContent = "Source — Webcam"; }
      else if (m===MODE.IMAGE){ sections.image.classList.add("show");  srcTitle.textContent = "Source — Uploaded Image"; }
      else if (m===MODE.VIDEO){ sections.video.classList.add("show");  srcTitle.textContent = "Source — Video File"; }
      else { sections.draw.classList.add("show");  srcTitle.textContent = "Source — Draw (SVG)"; }
      chips.forEach(c=> c.classList.toggle("active", c.dataset.mode===m));
    }
    chips.forEach(c => c.addEventListener("click", ()=> setMode(c.dataset.mode)));

    // Webcam
    function selectedDeviceId(){
      const map = ctrlCamera?._idMap || null;
      return map ? (map[state.Camera] || null) : null;
    }
    function parseRes(){
      const [w,h] = state.Resolution.split("x").map(Number);
      return { width:{ ideal:w }, height:{ ideal:h } };
    }
    function stopWebcam(){ if (currentStream){ currentStream.getTracks().forEach(t=>t.stop()); currentStream=null; } }
    async function restartWebcam(){
      if (!secure) return;
      if (mode!==MODE.WEBCAM) return;
      stopWebcam();
      try{
        const devId = selectedDeviceId();
        const base = { audio:false, video:{ ...parseRes() } };
        if (devId) base.video.deviceId = { exact: devId };
        else base.video.facingMode = { ideal: facing };
        const stream = await navigator.mediaDevices.getUserMedia(base);
        currentStream = stream; cam.srcObject = stream; await cam.play();
        statusEl.textContent = "camera ready";
      }catch(e){
        statusEl.textContent = "camera error";
        console.warn("getUserMedia failed", e);
      }
    }
    async function scanCameras(){
      if (!secure) return;
      try { const tmp=await navigator.mediaDevices.getUserMedia({video:true,audio:false}); tmp.getTracks().forEach(t=>t.stop()); } catch{}
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d=>d.kind==="videoinput");
      const labels = cams.map((d,i)=> d.label || `Camera ${i+1}`);
      const ids = cams.map(d=>d.deviceId);
      if (!labels.length){
        ctrlCamera.options(["(none found)"]).setValue("(none found)");
        ctrlCamera._idMap = {};
        return;
      }
      const map = {}; labels.forEach((name,i)=> map[name]=ids[i]);
      ctrlCamera._idMap = map;
      const names = Object.keys(map);
      ctrlCamera.options(names);
      if (!names.includes(state.Camera)) ctrlCamera.setValue(names[0]);
      await restartWebcam();
    }
    btnScan.onclick = () => scanCameras();
    btnSwapFacing.onclick = async () => { facing = (facing==="user"?"environment":"user"); ctrlCamera.setValue("(click Scan)"); await restartWebcam(); };

    // Upload image
    fileImage.addEventListener("change", async (e)=>{
      const f = e.target.files?.[0]; if (!f) return;
      const url = URL.createObjectURL(f);
      imgUpload.onload = ()=> URL.revokeObjectURL(url);
      imgUpload.src = url;
      setMode(MODE.IMAGE);
    });

    // Video file
    fileVideo.addEventListener("change", async (e)=>{
      const f = e.target.files?.[0]; if (!f) return;
      const url = URL.createObjectURL(f);
      vidFile.onloadeddata = ()=> { /* ready */ };
      vidFile.src = url;
      setMode(MODE.VIDEO);
    });

    // DRAW (SVG) — simple freehand lines
    let drawing=false, lastPt=null, strokeW=3;
    const strokes=[]; // for undo
    drawThin.onclick = ()=> strokeW=3;
    drawThick.onclick = ()=> strokeW=8;
    drawClear.onclick = ()=> { while (drawSvg.firstChild) drawSvg.removeChild(drawSvg.firstChild); strokes.length=0; };
    drawUndo.onclick = ()=> { const n=drawSvg.childNodes.length; if (n>0){ drawSvg.removeChild(drawSvg.lastChild); strokes.pop(); } };

    function svgPoint(evt){
      const rect = drawSvg.getBoundingClientRect();
      const x = (evt.clientX - rect.left) * (drawSvg.viewBox.baseVal.width  || rect.width)  / rect.width;
      const y = (evt.clientY - rect.top)  * (drawSvg.viewBox.baseVal.height || rect.height) / rect.height;
      return {x,y};
    }
    function ensureViewBox(){
      if (!drawSvg.getAttribute("viewBox")){
        const r = drawSvg.getBoundingClientRect();
        drawSvg.setAttribute("viewBox", `0 0 ${Math.max(1,r.width)} ${Math.max(1,r.height)}`);
      }
    }
    function startDraw(e){
      ensureViewBox();
      drawing=true;
      const p = svgPoint(e);
      lastPt=p;
      const pl = document.createElementNS("http://www.w3.org/2000/svg","polyline");
      pl.setAttribute("fill","none");
      pl.setAttribute("stroke","#ffffff");
      pl.setAttribute("stroke-linecap","round");
      pl.setAttribute("stroke-linejoin","round");
      pl.setAttribute("stroke-width", String(strokeW));
      pl.setAttribute("points", `${p.x},${p.y}`);
      drawSvg.appendChild(pl);
      strokes.push(pl);
    }
    function moveDraw(e){
      if (!drawing) return;
      const p = svgPoint(e);
      const pl = strokes[strokes.length-1];
      pl.setAttribute("points", pl.getAttribute("points")+" "+`${p.x},${p.y}`);
      lastPt=p;
    }
    function endDraw(){ drawing=false; lastPt=null; }

    drawSvg.addEventListener("pointerdown", e=>{ drawSvg.setPointerCapture(e.pointerId); startDraw(e); });
    drawSvg.addEventListener("pointermove", e=> moveDraw(e));
    drawSvg.addEventListener("pointerup",   ()=> endDraw());
    drawSvg.addEventListener("pointercancel",()=> endDraw());
    drawSvg.addEventListener("touchstart", e=> e.preventDefault(), {passive:false});
    drawSvg.addEventListener("gesturestart", e=> e.preventDefault());

    // Frame capture from current mode
    function sizeHidden(w,h){ hidden.width=w; hidden.height=h; }

    async function svgToCanvasBlob(quality=0.9){
      const r = drawSvg.getBoundingClientRect();
      const w = Math.round(r.width), h = Math.round(r.height);
      ensureViewBox();
      const svgStr = new XMLSerializer().serializeToString(drawSvg);
      const blob = new Blob([svgStr], {type:"image/svg+xml"});
      const url = URL.createObjectURL(blob);
      const img = new Image();
      img.decoding = "async";
      img.src = url;
      await img.decode().catch(()=>{});
      sizeHidden(w,h);
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(img,0,0,w,h);
      URL.revokeObjectURL(url);
      return new Promise(res => hidden.toBlob(res, "image/jpeg", quality));
    }

    async function grabFrameBlob(quality=0.85){
      if (mode===MODE.WEBCAM){
        if (!cam.videoWidth || !cam.videoHeight) return null;
        const w=cam.videoWidth, h=cam.videoHeight;
        sizeHidden(w,h);
        ctx.save();
        ctx.translate(state.Flip_X ? w : 0, state.Flip_Y ? h : 0);
        ctx.scale(state.Flip_X ? -1 : 1, state.Flip_Y ? -1 : 1);
        ctx.drawImage(cam,0,0,w,h);
        ctx.restore();
        return new Promise(r=> hidden.toBlob(r,"image/jpeg",quality));
      } else if (mode===MODE.IMAGE){
        if (!imgUpload.naturalWidth) return null;
        const w=imgUpload.naturalWidth, h=imgUpload.naturalHeight;
        sizeHidden(w,h);
        ctx.drawImage(imgUpload,0,0,w,h);
        return new Promise(r=> hidden.toBlob(r,"image/jpeg",quality));
      } else if (mode===MODE.VIDEO){
        if (!vidFile.videoWidth || !vidFile.videoHeight) return null;
        const w=vidFile.videoWidth, h=vidFile.videoHeight;
        sizeHidden(w,h);
        ctx.drawImage(vidFile,0,0,w,h);
        return new Promise(r=> hidden.toBlob(r,"image/jpeg",quality));
      } else {
        return await svgToCanvasBlob(quality);
      }
    }

    // Inference
    async function processOne(){
      if (inFlight) return;
      const frameBlob = await grabFrameBlob(0.85);
      if (!frameBlob) { statusEl.textContent="no frame yet"; return; }

      inFlight = true;
      const t0 = performance.now();
      try{
        statusEl.textContent = "processing…";
        const fd = new FormData();
        fd.append("frame", frameBlob, "frame.jpg");
        fd.append("prompt", state.Prompt || "");
        fd.append("strength", String(state.Strength));
        fd.append("guidance", String(state.Guidance));
        fd.append("steps", String(state.Steps));

        const res = await fetch("/process", { method:"POST", body:fd });
        if (!res.ok){
          let msg = `HTTP ${res.status}`;
          try{ const j=await res.json(); if (j?.error) msg=j.error; }catch{}
          throw new Error(msg);
        }
        const outBlob = await res.blob();
        if (out.dataset.url) URL.revokeObjectURL(out.dataset.url);
        const url = URL.createObjectURL(outBlob);
        out.dataset.url = url;
        out.src = url;
        statusEl.textContent = "done";
      }catch(e){
        console.warn("/process error", e);
        statusEl.textContent = "error";
      }finally{
        const dt = performance.now() - t0;
        avgLatencyMs = 0.8*avgLatencyMs + 0.2*dt;
        if (state.Live && liveTimer){
          clearInterval(liveTimer);
          liveTimer = setInterval(processOne, Math.max(200, Math.round(avgLatencyMs)));
        }
        inFlight = false;
      }
    }

    function toggleLive(on){
      state.Live = !!on;
      if (on){
        statusEl.textContent = "live…";
        if (liveTimer) clearInterval(liveTimer);
        liveTimer = setInterval(processOne, Math.max(200, Math.round(avgLatencyMs)));
      } else {
        statusEl.textContent = "idle";
        if (liveTimer) clearInterval(liveTimer);
        liveTimer = null;
      }
    }

    // Action buttons under panes
    document.getElementById("btnStart").onclick = ()=> toggleLive(true);
    document.getElementById("btnStop").onclick  = ()=> toggleLive(false);
    document.getElementById("btnSnap").onclick  = ()=> processOne();

    // Default mode
    setMode(MODE.WEBCAM);
  </script>
</body>
</html>
