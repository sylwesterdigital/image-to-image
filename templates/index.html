<!-- templates/index.html — lil-gui + adaptive live loop + in-flight guard -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
  />
  <title>Webcam ⇢ Real-Time LCM (img2img)</title>
  <link rel="icon" href="/static/favicon.ico" />
  <script type="importmap">
    {
      "imports": {
        "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.19/dist/lil-gui.esm.min.js"
      }
    }
  </script>
  <style>
    :root { --gap: 12px; }
    html, body { margin: 0; padding: 0; background: #0b0b0c; color: #e9e9ea; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { display: flex; flex-direction: column; min-height: 100svh; }
    header { padding: 10px var(--gap); font-weight: 600; letter-spacing: .3px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: var(--gap); padding: 0 var(--gap) var(--gap); }
    .pane { background: #111114; border: 1px solid #242428; border-radius: 14px; overflow: hidden; position: relative; min-height: 40svh; }
    .pane h3 { position: absolute; z-index: 2; top: 8px; left: 10px; margin: 0; font-size: 12px; letter-spacing: .4px; opacity: .8; background: rgba(0,0,0,.4); padding: 4px 6px; border-radius: 8px; }
    video, img, canvas { width: 100%; height: 100%; object-fit: cover; display: block; }
    footer { padding: 8px var(--gap); opacity: .7; font-size: 12px; }
    #overlay {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,.8); color: #fff; font: 14px/1.6 system-ui, sans-serif; z-index: 9999; text-align: center; padding: 24px;
    }
    #overlay.show { display: flex; }
    @media (max-width: 800px) {
      .grid { grid-template-columns: 1fr; }
      .pane { min-height: 45svh; }
    }
    .pill { position: fixed; bottom: 12px; left: 12px; padding: 6px 10px; border-radius: 999px; border: 1px solid #2a2a2e; background: #151518; font-size: 12px; opacity: .9; }
  </style>
</head>
<body>
  <div id="overlay" class="show">
    <div>
      <div style="font-size:18px; margin-bottom:8px;">Secure context required</div>
      <div>Open via <strong>https://localhost:5000</strong> or <strong>https://&lt;your-mac-ip&gt;:5000</strong> and accept the certificate.</div>
    </div>
  </div>

  <div class="wrap">
    <header>Webcam ⇢ Real-Time LCM (img2img)</header>
    <div class="grid">
      <div class="pane">
        <h3>Webcam</h3>
        <video id="cam" autoplay playsinline muted></video>
      </div>
      <div class="pane">
        <h3>Output</h3>
        <img id="out" alt="Model output" />
      </div>
    </div>
    <footer>Steps 2–4 for speed · Strength controls deviation.</footer>
  </div>

  <span id="status" class="pill">idle</span>
  <canvas id="hidden" style="display:none;"></canvas>

  <script type="module">
    import { GUI } from "lil-gui";

    // --- Secure-context gate ---
    const overlay = document.getElementById("overlay");
    const secure = location.protocol === "https:" || ["localhost", "127.0.0.1", "[::1]"].includes(location.hostname);
    if (secure) overlay.classList.remove("show");

    // --- DOM refs ---
    const cam = document.getElementById("cam");
    const out = document.getElementById("out");
    const hidden = document.getElementById("hidden");
    const ctx = hidden.getContext("2d");
    const statusEl = document.getElementById("status");

    // --- State ---
    let currentStream = null;
    let inFlight = false;
    let avgLatencyMs = 900;   // adaptive pacing
    let liveTimer = null;

    // --- lil-gui params ---
    const state = {
      Prompt: "cinematic portrait, dramatic lighting",
      Strength: 0.5,
      Guidance: 1.0,         // LCM sweet spot: ~0–2
      Steps: 4,
      Live: false,

      Camera: "(choose)",
      Facing: "user",
      Resolution: "1280x720",
      Flip_X: false,
      Flip_Y: false,
      Refresh_Cameras: () => populateCameras(true),
      Process_Frame: () => processOne(),
      Start_Live: () => guiControllers.Live.setValue(true),
      Stop_Live:  () => guiControllers.Live.setValue(false)
    };

    // --- GUI setup ---
    const gui = new GUI({ title: "Controls" });
    const gCam = gui.addFolder("Camera"); gCam.open();
    const gModel = gui.addFolder("Model"); gModel.open();

    const guiControllers = {
      Camera: gCam.add(state, "Camera", ["(loading…)"]).name("Device").onChange(onCameraChanged),
      Facing: gCam.add(state, "Facing", ["user", "environment", "none"]).onChange(restartStream),
      Resolution: gCam.add(state, "Resolution", ["640x480","1280x720","1920x1080"]).onChange(restartStream),
      Flip_X: gCam.add(state, "Flip_X").onChange(()=> drawFlipPreview()),
      Flip_Y: gCam.add(state, "Flip_Y").onChange(()=> drawFlipPreview()),
      Refresh: gCam.add(state, "Refresh_Cameras").name("↻ Rescan"),

      Prompt: gModel.add(state, "Prompt"),
      Strength: gModel.add(state, "Strength", 0.05, 1, 0.01),
      Guidance: gModel.add(state, "Guidance", 0, 6, 0.1),
      Steps: gModel.add(state, "Steps", 2, 8, 1),
      Live: gModel.add(state, "Live").onChange(toggleLive),
      Snap: gModel.add(state, "Process_Frame").name("Process one frame"),
      Start: gModel.add(state, "Start_Live").name("Start live"),
      Stop: gModel.add(state, "Stop_Live").name("Stop live"),
    };

    // --- Cameras ---
    function stopStream() {
      if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); currentStream = null; }
    }

    function selectedDeviceId() {
      const ctrl = guiControllers.Camera;
      if (!ctrl || !ctrl._idMap) return null;
      return ctrl._idMap[state.Camera] || null;
    }

    function parseResolution() {
      const [w, h] = state.Resolution.split("x").map(Number);
      return { width: { ideal: w }, height: { ideal: h } };
    }

    async function restartStream() {
      if (!secure) return;
      stopStream();
      try {
        const devId = selectedDeviceId();
        const base = { audio: false, video: { ...parseResolution() } };
        if (devId) base.video.deviceId = { exact: devId };
        else if (state.Facing !== "none") base.video.facingMode = { ideal: state.Facing };
        const stream = await navigator.mediaDevices.getUserMedia(base);
        currentStream = stream; cam.srcObject = stream; await cam.play();
        statusEl.textContent = "camera ready";
      } catch (e) {
        statusEl.textContent = "camera error";
        console.warn("getUserMedia failed", e);
      }
    }

    async function populateCameras(force=false) {
      try {
        if (!secure) return;
        if (force) {
          try { const tmp = await navigator.mediaDevices.getUserMedia({video:true,audio:false}); tmp.getTracks().forEach(t=>t.stop()); } catch {}
        }
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === "videoinput");
        const labels = cams.map((d,i)=> d.label || `Camera ${i+1}`);
        const ids = cams.map(d => d.deviceId);

        const ctrl = guiControllers.Camera;
        ctrl._options.length = 0;
        if (!labels.length) {
          ctrl.setOptions(["(none found)"]); ctrl.setValue("(none found)"); return;
        }
        const map = {}; labels.forEach((name, idx) => map[name] = ids[idx]);
        ctrl._idMap = map;
        ctrl.setOptions(Object.keys(map));
        if (!Object.keys(map).includes(state.Camera)) ctrl.setValue(Object.keys(map)[0]);
        await restartStream();
      } catch (e) {
        console.warn("populateCameras failed", e);
      }
    }

    function onCameraChanged() { restartStream(); }

    // --- Frame capture ---
    function drawFlipPreview() {
      // no-op placeholder (flip handled in grabFrameBlob); keeps GUI responsive
    }

    async function grabFrameBlob(quality = 0.85) {
      const w = cam.videoWidth, h = cam.videoHeight;
      if (!w || !h) return null;
      hidden.width = w; hidden.height = h;
      ctx.save();
      ctx.translate(state.Flip_X ? w : 0, state.Flip_Y ? h : 0);
      ctx.scale(state.Flip_X ? -1 : 1, state.Flip_Y ? -1 : 1);
      ctx.drawImage(cam, 0, 0, w, h);
      ctx.restore();
      return new Promise(resolve => hidden.toBlob(resolve, "image/jpeg", quality));
    }

    // --- Inference + adaptive pacing ---
    async function processOne() {
      if (inFlight) return;   // prevent overlap
      inFlight = true;
      const t0 = performance.now();
      try {
        statusEl.textContent = "processing…";
        const frameBlob = await grabFrameBlob(0.85);
        if (!frameBlob) { statusEl.textContent = "no frame yet"; return; }

        const fd = new FormData();
        fd.append("frame", frameBlob, "frame.jpg");
        fd.append("prompt", state.Prompt || "");
        fd.append("strength", String(state.Strength));
        fd.append("guidance", String(state.Guidance));
        fd.append("steps", String(state.Steps));

        const res = await fetch("/process", { method: "POST", body: fd });
        if (!res.ok) {
          const err = await res.json().catch(()=>({error:"unknown"}));
          throw new Error(err.error || `HTTP ${res.status}`);
        }
        const outBlob = await res.blob();
        if (out.dataset.url) URL.revokeObjectURL(out.dataset.url);
        const url = URL.createObjectURL(outBlob);
        out.dataset.url = url;
        out.src = url;
        statusEl.textContent = "done";
      } catch (e) {
        console.warn(e);
        statusEl.textContent = "error";
      } finally {
        const dt = performance.now() - t0;
        // EMA to adapt loop to actual latency (min interval 200ms)
        avgLatencyMs = 0.8 * avgLatencyMs + 0.2 * dt;
        if (state.Live && liveTimer) {
          clearInterval(liveTimer);
          liveTimer = setInterval(processOne, Math.max(200, Math.round(avgLatencyMs)));
        }
        inFlight = false;
      }
    }

    function toggleLive(on) {
      if (on) {
        statusEl.textContent = "live…";
        if (liveTimer) clearInterval(liveTimer);
        liveTimer = setInterval(processOne, Math.max(200, Math.round(avgLatencyMs)));
      } else {
        statusEl.textContent = "idle";
        if (liveTimer) clearInterval(liveTimer);
        liveTimer = null;
      }
    }

    // --- Boot ---
    (async function boot(){
      if (!secure) return;
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        const legacy = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        if (legacy) {
          navigator.mediaDevices = navigator.mediaDevices || {};
          navigator.mediaDevices.getUserMedia = (c) => new Promise((res, rej) => legacy.call(navigator, c, res, rej));
        }
      }
      await populateCameras(true);
    })();
  </script>
</body>
</html>
